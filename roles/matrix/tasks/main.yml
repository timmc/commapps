---
# Double-check. See redundant task in commdata for more info.
- name: "Confirm that commdata is mounted (for matrix data)"
  shell: mountpoint /srv/commdata
  changed_when: False

# Mechanism for vars/vault separation for role vars
- include_vars: "{{ role_path }}/vars/vault.yml"

# ----

- name: "Dir for matrix files"
  file:
    path: "{{ matrix__cfg.data_dir }}"
    state: directory

- name: "User and home dir for dendrite"
  user:
    name: "{{ matrix__cfg.user }}"
    system: yes
    home: "{{ matrix__cfg.data_dir }}/dendrite"
    shell: /bin/bash

- name: "PostgreSQL for backing store"
  apt:
    name:
      - postgresql
      - python3-psycopg2 # Python adapter, required for postgresql ansible modules

- name: "A place for dendrite postgres data"
  file:
    state: directory
    path: "{{ matrix__cfg.data_dir }}/dendrite/postgres"
    owner: postgres
    group: postgres

# NB: This relies on a hacky Before+RequiredBy declaration in
# commdata-fs.service that ensures postgresql won't start until after
# the commdata filesystem is mounted.
- name: "Allow postgres to store dendrite tables in commdata"
  community.postgresql.postgresql_tablespace:
    tablespace: "{{ matrix__cfg.pg.tablespace }}"
    location: "{{ matrix__cfg.data_dir }}/dendrite/postgres"
  become: true
  become_user: postgres

- name: "Dendrite DB, stored in commdata"
  community.postgresql.postgresql_db:
    name: "{{ matrix__cfg.pg.db }}"
    tablespace: "{{ matrix__cfg.pg.tablespace }}"
    encoding: UTF-8
  become: true
  become_user: postgres

- name: "Dendrite user account in postgres"
  community.postgresql.postgresql_user:
    name: "{{ matrix__cfg.pg.user }}"
    password: "{{ matrix__cfg.pg.password }}"
    db: "{{ matrix__cfg.pg.db }}"
  no_log: true # secrets
  become: true
  become_user: postgres


#== Building dendrite

- name: "Script to build from source"
  template:
    src: "{{ role_path }}/templates/build-dendrite.sh.j2"
    dest: "{{ matrix__cfg.data_dir }}/build-dendrite.sh"
    mode: a=rx

- name: "Build dendrite"
  command:
    creates: "{{ matrix__cfg.data_dir }}/dendrite/bin/dendrite-{{ matrix__cfg.dendrite_version }}/dendrite-monolith-server"
    cmd: "{{ matrix__cfg.data_dir }}/build-dendrite.sh"
  become: yes
  become_user: "{{ matrix__cfg.user }}"
  environment:
    GOLANG_VER: "{{ matrix__cfg.golang_version }}"
    GOLANG_SHA256: "{{ matrix__cfg.golang_archive_sha256 }}"
    DENDRITE_REPO_URL: "{{ matrix__cfg.dendrite_repo_url }}"
    DENDRITE_VER: "{{ matrix__cfg.dendrite_version }}"
    DENDRITE_COMMIT_SHA1: "{{ matrix__cfg.dendrite_commit_sha1 }}"

- name: "Symlink to current version for ease of reference"
  file:
    state: link
    path: "{{ matrix__cfg.data_dir }}/dendrite/bin/current"
    src: "dendrite-{{ matrix__cfg.dendrite_version }}"
    follow: false # set ownership on link, not dest
    owner: "{{ matrix__cfg.user }}"
    group: "{{ matrix__cfg.user }}"
  notify: "dendrite change"

#== TLS termination via nginx

- name: "Certificate config"
  copy:
    content: "{{ item.config | to_nice_json }}"
    dest: "/opt/commapps/certbot/domains.d/{{ item.filename }}"
  loop: "{{ matrix__cfg.certificates}}"
  notify: "certs config update"

- name: "Install nginx proxy"
  copy:
    content: |
      # Configuration for {{ matrix__cfg.domain_host }} reverse proxy
      server {
        listen 443 ssl;
        server_name {{ matrix__cfg.domain_host }};

        ssl_certificate /srv/commdata/etc-letsencrypt/live/{{ matrix__cfg.domain_host }}/fullchain.pem;
        ssl_certificate_key /srv/commdata/etc-letsencrypt/live/{{ matrix__cfg.domain_host }}/privkey.pem;

        # If someone opens the subdomain in their browser, send them
        # to a useful page.
        location ~ ^/$ {
          return 302 {{ matrix__cfg.root_url_redirect }};
        }

        # Registration UI is separate application. Only expose routes
        # that need to be public; admin API will only be callable from
        # on-host.
        location ~ ^/regui/(static|register) {
          proxy_pass http://localhost:{{ matrix__cfg.regui.listen_port }};
          # The app can record which IP addresses used which tokens
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_read_timeout 30;
        }

        # Everything else goes to Dendrite.
        location ~ ^/.+ {
          proxy_pass http://127.0.0.1:{{ matrix__cfg.dendrite_listen_port }};
          proxy_set_header Host $host;
          # The sync API wants X-Real-IP (probably other APIs do as well)
          proxy_set_header X-Real-IP $remote_addr;
          proxy_read_timeout 600;
        }

        # Allow file uploads. Dendrite has its own config on the Media
        # API side, so this can be somewhat permissive.
        client_max_body_size 15m;
      }
    dest: "/etc/nginx/sites-available/{{ matrix__cfg.domain_host }}.conf"
  notify: "matrix nginx config"

- name: "Enable nginx proxy"
  file:
    src: "/etc/nginx/sites-available/{{ matrix__cfg.domain_host }}.conf"
    dest: "/etc/nginx/sites-enabled/{{ matrix__cfg.domain_host }}.conf"
    state: link
  notify: "matrix nginx config"


#== Configuration

- name: "Directory for dendrite logs"
  file:
    path: "{{ matrix__cfg.data_dir }}/dendrite/logs"
    state: directory
    owner: "{{ matrix__cfg.user }}"
    group: "{{ matrix__cfg.user }}"
    # Logs could contain user info
    mode: u=rwx,g=,o=

- name: "Signing key"
  copy:
    content: "{{ matrix__cfg.signing_key }}"
    dest: "{{ matrix__cfg.data_dir }}/dendrite/matrix_key.pem"
    owner: "{{ matrix__cfg.user }}"
    group: "{{ matrix__cfg.user }}"
    mode: u=r,g=,o=
  no_log: true
  notify: "dendrite change"

- name: "Dendrite config file"
  template:
    src: "{{ role_path }}/templates/{{ matrix__cfg.dendrite_config_template }}"
    dest: "{{ matrix__cfg.data_dir }}/dendrite/dendrite.yaml"
    owner: "{{ matrix__cfg.user }}"
    group: "{{ matrix__cfg.user }}"
    mode: u=r,g=,o=
  no_log: true # contains secrets
  notify: "dendrite change"

- name: "Dendrite launcher"
  copy:
    content: |
      #!/bin/bash
      set -eu -o pipefail
      {{ matrix__cfg.data_dir|quote }}/dendrite/bin/current/dendrite-monolith-server \
          --config {{ matrix__cfg.data_dir|quote }}/dendrite/dendrite.yaml \
          --http-bind-address localhost:{{ matrix__cfg.dendrite_listen_port|quote }} \
          >> {{ matrix__cfg.data_dir|quote }}/dendrite/logs/stdout.log \
          2>> {{ matrix__cfg.data_dir|quote }}/dendrite/logs/stderr.log
    dest: "{{ matrix__cfg.data_dir }}/dendrite/run.sh"
    owner: "{{ matrix__cfg.user }}"
    group: "{{ matrix__cfg.user }}"
    mode: a+x
  notify: "dendrite change"

# Only needed for stderr/stdout files; dendrite rotates its own logs.
# stderr.log actually seems to just be a terser version of what's in
# Monolith.log, but keeping it anyway for now.
- name: "Log rotation"
  copy:
    content: |
      {{ matrix__cfg.data_dir|quote }}/dendrite/logs/stdout.log {{ matrix__cfg.data_dir|quote }}/dendrite/logs/stderr.log {
          daily
          rotate 10
          missingok
          create 600 {{ matrix__cfg.user }} {{ matrix__cfg.user }}
      }
    dest: "/etc/logrotate.d/{{ matrix__cfg.service_name }}-launcher"

- name: "Dendrite systemd service unit file"
  copy:
    content: |
      [Unit]
      Description=Dendrite Matrix server

      # nginx not listed, since it's not a hard requirement for the
      # process, just the service being reachable.
      Requires=commdata-fs.service
      Requires=postgresql.service
      After=commdata-fs.service
      After=postgresql.service

      # If it auto-restarts this many times in this many seconds, stop
      # auto-restarting.
      StartLimitBurst=3
      StartLimitIntervalSec=30

      [Service]
      Type=simple
      ExecStart={{ matrix__cfg.data_dir }}/dendrite/run.sh
      User={{ matrix__cfg.user }}
      Group={{ matrix__cfg.user }}

      Restart=on-failure
      RestartSec=5s

      # Dendrite needs to talk to lots of homeservers
      LimitNOFILE=8K
      # Dendrite is experimental and sometimes leaks memory. If
      # there's an OOM situation, it's probably Dendrite, so prefer to
      # kill it.
      OOMScoreAdjust=500

      [Install]
      WantedBy=multi-user.target
    dest: "/etc/systemd/system/{{ matrix__cfg.service_name }}.service"
  register: matrix__dendrite_service_file

- name: "Reload systemd config if dendrite unit file changed"
  command: systemctl daemon-reload
  when: matrix__dendrite_service_file.changed

- name: "Enable dendrite service"
  service:
    name: "{{ matrix__cfg.service_name }}"
    enabled: yes
    state: started


#== Element web client

- name: "Dir for element files"
  file:
    path: "{{ matrix__cfg.data_dir }}/element"
    state: directory

- name: "Element release key"
  copy:
    src: "{{ role_path }}/files/element-release-key.asc"
    dest: "{{ matrix__cfg.data_dir }}/element/element-release-key.asc"

- name: "Make GPG keyring for element key"
  command:
    argv:
      - gpg
      - '--no-default-keyring'
      - '--keyring'
      - "{{ matrix__cfg.data_dir }}/element/release-keys.gpg"
      - '--import'
      - "{{ matrix__cfg.data_dir }}/element/element-release-key.asc"
    creates: "{{ matrix__cfg.data_dir }}/element/release-keys.gpg"

- name: "Dir for element site versions"
  file:
    path: "{{ matrix__cfg.data_dir }}/element/site"
    state: directory

- name: "Dir for configured element version"
  file:
    path: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}"
    state: directory

- name: "Download Element tarball"
  get_url:
    url: "https://github.com/vector-im/element-web/releases/download/{{ matrix__cfg.element.version|urlencode }}/element-{{ matrix__cfg.element.version|urlencode }}.tar.gz"
    dest: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/tarball.tar.gz"

- name: "Download Element signature"
  get_url:
    url: "https://github.com/vector-im/element-web/releases/download/{{ matrix__cfg.element.version|urlencode }}/element-{{ matrix__cfg.element.version|urlencode }}.tar.gz.asc"
    dest: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/tarball.tar.gz.asc"

# Do this all in one step so we can use the "creates" option to skip easily.
- name: "Verify and extract element tarball"
  shell:
    creates: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/www"
    chdir: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}"
    executable: /bin/bash
    cmd: |
      set -eu -o pipefail
      gpg --no-default-keyring --keyring {{ matrix__cfg.data_dir|quote }}/element/release-keys.gpg \
          --verify tarball.tar.gz.asc tarball.tar.gz
      tar xzf tarball.tar.gz -- element-{{ matrix__cfg.element.version|quote }}
      mv -- element-{{ matrix__cfg.element.version|quote }} www

# The index files points to a favicon.878a87c.ico (878a87c appears to be an
# MD5 prefix of the file's contents) but I want a predictable location for
# overwriting. There's also a regular favicon.ico with the same contents,
# so make the less predictable name a symlink to that.
- name: "Make a predictable location for element-web favicon"
  shell:
    creates: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/www/favicon-replaced.txt"
    chdir: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/www"
    executable: /bin/bash
    cmd: |
      set -eu -o pipefail
      (
        cd vector-icons
        for f in favicon.*.ico; do
            unlink -- "./$f"
            ln -ns ./favicon.ico "./$f"
        done
      )
      touch favicon-replaced.txt

- name: "Use own favicon for element-web"
  copy:
    src: "{{ role_path }}/files/favicon-ball-matrix.ico"
    dest: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/www/vector-icons/favicon.ico"

- name: "Configure element-web"
  copy:
    # https://github.com/vector-im/element-web/blob/develop/docs/config.md
    content: |
      {
        "default_server_config": {
          "m.homeserver": {
            "base_url": "https://{{ matrix__cfg.domain_host }}",
            "server_name": "{{ matrix__cfg.domain_identity }}"
          }
        },
        "show_labs_settings": true,
        "brand": {{ matrix__cfg.element.brand|tojson }},
        "features": {
          "feature_thread": true
        },
        "settingDefaults": {
          "UIFeature.registration": false
        }
      }
    dest: "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/www/config.json"

# Do this after all other setup of the configured version
- name: "Symlink to current version for ease of reference"
  file:
    state: link
    path: "{{ matrix__cfg.data_dir }}/element/site/current"
    src: "element-{{ matrix__cfg.element.version }}"

# nginx has weird behavior where using add_header in a location wipes
# out the server-wide headers for that location...
- name: "Nginx includes for element-web global headers"
  copy:
    content: |
      add_header X-Frame-Options SAMEORIGIN;
      add_header X-Content-Type-Options nosniff;
      add_header X-XSS-Protection "1; mode=block";
      # The index page declares its own CSP restrictions; this is just
      # copied from that (in version 1.11.13) but:
      # - Removes the permission for running Google/reCAPTCHA scripts (won't be using)
      # - Adds frame-ancestors=none (as recommended in element-web documentation)
      # - Adds base-uri=none
      #
      # There are some errors in the browser console about unsafe-inline scripts being
      # blocked, but it doesn't seem to cause a problem?
      add_header Content-Security-Policy "default-src 'none'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-eval'; img-src * blob: data:; connect-src *; font-src 'self' data:; media-src * blob: data:; child-src * blob: data:; worker-src 'self' blob:; frame-src * blob: data:; form-action 'self'; manifest-src 'self'; frame-ancestors 'none'; base-uri 'none'";
      add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";
    dest: "{{ matrix__cfg.data_dir }}/element/nginx-global-headers.conf"
  notify: "matrix nginx config"

# Certs are configured elsewhere in task file, together with dendrite/matreg
- name: "Install nginx proxy"
  copy:
    content: |
      # Configuration for element-web at {{ matrix__cfg.element.domain }}
      server {
        listen 443 ssl;
        server_name {{ matrix__cfg.element.domain }};

        ssl_certificate /srv/commdata/etc-letsencrypt/live/{{ matrix__cfg.element.domain }}/fullchain.pem;
        ssl_certificate_key /srv/commdata/etc-letsencrypt/live/{{ matrix__cfg.element.domain }}/privkey.pem;

        root "{{ matrix__cfg.data_dir }}/element/site/element-{{ matrix__cfg.element.version }}/www";
        index index.html;

        include {{ matrix__cfg.data_dir }}/element/nginx-global-headers.conf;

        # Set no-cache for the version, config and index.html
        # so that browsers always check for a new copy of Element Web.
        location = /index.html {
          include {{ matrix__cfg.data_dir }}/element/nginx-global-headers.conf;
          add_header Cache-Control "no-cache";
        }
        location = /version {
          include {{ matrix__cfg.data_dir }}/element/nginx-global-headers.conf;
          add_header Cache-Control "no-cache";
        }
        # covers config.json and config.hostname.json requests as it is a prefix
        location /config {
          include {{ matrix__cfg.data_dir }}/element/nginx-global-headers.conf;
          add_header Cache-Control "no-cache";
        }

        error_page 500 502 503 504 /50x.html;
      }
    dest: "/etc/nginx/sites-available/{{ matrix__cfg.element.domain }}.conf"
  notify: "matrix nginx config"

- name: "Enable element-web nginx site"
  file:
    src: "/etc/nginx/sites-available/{{ matrix__cfg.element.domain }}.conf"
    dest: "/etc/nginx/sites-enabled/{{ matrix__cfg.element.domain }}.conf"
    state: link
  notify: "matrix nginx config"


#== Matrix registration frontend

- name: "User and home dir for matreg"
  user:
    name: "{{ matrix__cfg.regui.user }}"
    system: yes
    home: "{{ matrix__cfg.data_dir }}/regui"
    shell: /bin/bash

- name: "Deps for matrix-registration"
  apt:
    name:
      # Virtualenv
      - python3
      - python3-pip
      - python3-virtualenv
      # Administration
      - sqlite3

- name: "Setup by matreg user"
  become: yes
  become_user: "{{ matrix__cfg.regui.user }}"
  block:
    # Maintain a different virtualenv for each Python version so that when
    # the operating system upgrades Python and *uninstalls the old default
    # Python* that the venv pointed to, the next Ansible run will recreate
    # the venv with the new Python version.

    - name: "Discover Python version"
      shell: |
        python3 -c "import platform; print(platform.python_version(), end='')"
      failed_when: False
      changed_when: False
      register: matreg__pyver
      check_mode: no # Run in normal mode, since it registers a variable

    - name: "Install matrix-registration in virtualenv"
      pip:
        name:
          - "{{ matrix__cfg.regui.package }}"
        virtualenv: "{{ matrix__cfg.data_dir }}/regui/venv_py{{ matreg__pyver.stdout}}"
        virtualenv_python: python3
      notify: "regui change"

    - name: "Symlink for virtualenv matching current Python"
      file:
        state: link
        src: "{{ matrix__cfg.data_dir }}/regui/venv_py{{ matreg__pyver.stdout }}"
        dest: "{{ matrix__cfg.data_dir }}/regui/venv"
      notify: "regui change"

    - name: "Directory for regui logs"
      file:
        path: "{{ matrix__cfg.data_dir }}/regui/logs"
        state: directory
        # Logs could contain user info
        mode: u=rwx,g=,o=

    - name: "Configuration for registration app"
      template:
        src: "{{ role_path }}/templates/matrix-registration.yaml.j2"
        dest: "{{ matrix__cfg.data_dir }}/regui/config.yaml"
      no_log: true # secrets
      notify: "regui change"

    - name: "Registration app launcher"
      copy:
        content: |
          #!/bin/bash
          set -eu -o pipefail
          {{ matrix__cfg.data_dir|quote }}/regui/venv/bin/matrix-registration \
            --config-path {{ matrix__cfg.data_dir|quote }}/regui/config.yaml \
            serve \
            >> {{ matrix__cfg.data_dir|quote }}/regui/logs/stdout.log \
            2>> {{ matrix__cfg.data_dir|quote }}/regui/logs/stderr.log
        dest: "{{ matrix__cfg.data_dir }}/regui/run.sh"
        mode: a+x
      notify: "regui change"

    - name: "Registration app admin script"
      copy:
        content: |
          #!/bin/bash
          # Make calls to admin API via curl
          set -eu -o pipefail

          if [[ "$#" -lt 1 ]]; then
            echo "Usage: admin.sh /api/... [optional curl args...]"
            exit 1
          fi

          api_path="$1" # e.g. "version"
          shift

          if [[ ! "$api_path" =~ ^/api/.* ]]; then
            echo "Path must start with /api/"
            exit 1
          fi

          curl -sS \
            -H "Authorization: SharedSecret {{ matrix__cfg.regui.admin_password }}" \
            "http://localhost:{{ matrix__cfg.regui.listen_port }}${api_path}" \
            "$@"
        dest: "{{ matrix__cfg.data_dir }}/regui/admin.sh"
        mode: u=rwx,g=,o=
      no_log: true # secrets


- name: "Log rotation"
  copy:
    content: |
      {{ matrix__cfg.data_dir|quote }}/regui/logs/stdout.log {{ matrix__cfg.data_dir|quote }}/regui/logs/stderr.log {
          daily
          rotate 20
          missingok
          create 600 {{ matrix__cfg.regui.user }} {{ matrix__cfg.regui.user }}
      }
    dest: "/etc/logrotate.d/{{ matrix__cfg.regui.service_name }}-launcher"

- name: "Registration systemd service unit file"
  copy:
    content: |
      [Unit]
      Description=Matrix registration service

      # nginx not listed, since it's not a hard requirement for the
      # process, just the service being reachable.
      Requires=commdata-fs.service
      After=commdata-fs.service

      # If it auto-restarts this many times in this many seconds, stop
      # auto-restarting.
      StartLimitBurst=3
      StartLimitIntervalSec=30

      [Service]
      Type=simple
      ExecStart={{ matrix__cfg.data_dir }}/regui/run.sh
      User={{ matrix__cfg.regui.user }}
      Group={{ matrix__cfg.regui.user }}

      Restart=on-failure
      RestartSec=5s

      [Install]
      WantedBy=multi-user.target
    dest: "/etc/systemd/system/{{ matrix__cfg.regui.service_name }}.service"
  register: matrix__regui_service_file
  notify: "regui change"

- name: "Reload systemd config if registration unit file changed"
  command: systemctl daemon-reload
  when: matrix__regui_service_file.changed

- name: "Enable registration service"
  service:
    name: "{{ matrix__cfg.regui.service_name }}"
    enabled: yes
    state: started

# Flushing handlers here allows them to use role variables
- name: "Flush handlers"
  meta: flush_handlers
